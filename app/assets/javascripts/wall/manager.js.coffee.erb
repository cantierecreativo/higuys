#= require ./wall
#= require ./autoshoot_control
#= require ./client

class @Manager
  constructor: (pusherChannel, userId, $wallDom, $autoshootControlDom, $muteControlDom) ->
    @wall = new Wall($wallDom, userId)
    @audio = $wallDom.find('audio').get(0)
    @myView = @wall.myView
    @autoshoot = new AutoshootControl($autoshootControlDom)
    @mute = false
    $muteControlDom.click =>
      @mute = !@mute
      $muteControlDom.toggleClass('is-mute', @mute)

    @client = new Client()

    pusher = new Pusher('<%= ENV.fetch("PUSHER_KEY") %>')
    @channel = pusher.subscribe(pusherChannel)

    @channel.bind 'join',  (data) => @wall.addTempFriend(data.user_id)
    @channel.bind 'leave', (data) => @refreshStatus()
    @channel.bind 'photo', (data) => @refreshStatus()

    @autoshoot.on 'requestStateChange', (state) =>
      if state == 'COUNTDOWN'
        @restartCountdown()
      else if state == 'PAUSED'
        clearTimeout(@countdownTimeout)
        @countdownTimeout =  null
        @autoshoot.setState('PAUSED')

    @myView.on 'requestShoot', =>
      return if @isShooting
      return if @autoshoot.state == 'SHOOTING'
      return if @autoshoot.state == 'WAITING_PERMISSIONS'

      clearTimeout(@countdownTimeout)
      @countdownTimeout = null
      @shoot()

    @refreshStatus (err) =>
      @myView.startStream (e) =>
        if e
          alert "Ouch... we are unable to start the camera stream. Are you using Chrome or Firefox? Then try to refresh the browser!"
        else
          @shoot()

  refreshStatus: (cb) ->
    @client.fetchStatus (err, result) =>
      if err
        cb?(err)
      else
        @wall.refreshFriends(result)
        cb?()

  shoot: ->
    getPhoto = =>
      @wall.myView.shootPhoto (err, photoDataUrl) =>
        @notifyNewPhoto(photoDataUrl)
        @restartCountdown()

    @autoshoot.setState('SHOOTING')
    @wall.myView.toggleVideo(true)
    @audio.play() unless @mute
    setTimeout(getPhoto, 2200)

  restartCountdown: ->
    @remainingSeconds = 40
    @autoshoot.setState('COUNTDOWN')

    update = =>
      @remainingSeconds -= 1

      if @remainingSeconds == 0
        @countdownTimeout = null
        @shoot()
      else
        @autoshoot.setRemainingSeconds(@remainingSeconds)
        @countdownTimeout = setTimeout(update, 1000)

    update()

  notifyNewPhoto: (photoDataUrl) ->
    @client.requestUpload (err, result) =>
      @client.s3Put result.upload_url, @dataUriToBlob(photoDataUrl), (err, data) =>
        @client.notifyPhotoUpload(result.upload_url)

  dataUriToBlob: (dataUrl) ->
    byteString = undefined
    if dataUrl.split(",")[0].indexOf("base64") >= 0
      byteString = atob(dataUrl.split(",")[1])
    else
      byteString = unescape(dataUrl.split(",")[1])
    mimeString = dataUrl.split(",")[0].split(":")[1].split(";")[0]
    ia = new Uint8Array(byteString.length)
    i = 0
    while i < byteString.length
      ia[i] = byteString.charCodeAt(i)
      i++
    new Blob([ia], type: mimeString)

